var searchIndex = {};
searchIndex['splitmut'] = {"items":[[4,"SplitMutError","splitmut","Error returned from get*_mut functions.",null,null],[13,"NoValue","","No value was found for the specified key (like when get_mut would return None)",0,null],[13,"SameValue","","The same value has already been returned (earlier in the same tuple)",0,null],[8,"SplitMut","","Just add `use splitmut::SplitMut;` to have these methods working on\nmutable slices, Vec, VecDeque, HashMap and BTreeMap.",null,null],[10,"get1_mut","","Wrapper for get_mut, used internally.",1,{"inputs":[{"name":"splitmut"},{"name":"k"}],"output":{"name":"option"}}],[10,"get1_unchecked_mut","","Wrapper for get_unchecked_mut, used internally.",1,{"inputs":[{"name":"splitmut"},{"name":"k"}],"output":{"name":"v"}}],[11,"get2_mut","","Returns two mutable references to two distinct values within\nthe same collection.",1,null],[11,"get3_mut","","Returns three mutable references to three distinct values within\nthe same collection.",1,null],[11,"get4_mut","","Returns four mutable references to four distinct values within\nthe same collection.",1,null],[11,"get2_unchecked_mut","","Returns two mutable references to two distinct values within\nthe same collection.",1,null],[11,"get3_unchecked_mut","","Returns three mutable references to three distinct values within\nthe same collection.",1,null],[11,"get4_unchecked_mut","","Returns four mutable references to four distinct values within\nthe same collection.",1,null],[11,"fmt","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"splitmuterror"}],"output":{"name":"splitmuterror"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"ordering"}}],[11,"eq","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"splitmuterror"}],"output":{"name":"bool"}}],[11,"description","","",0,{"inputs":[{"name":"splitmuterror"}],"output":{"name":"str"}}],[11,"fmt","","",0,{"inputs":[{"name":"splitmuterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get1_mut","collections::vec","",2,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get1_unchecked_mut","","",2,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"v"}}],[11,"get1_mut","collections::vec_deque","",3,{"inputs":[{"name":"vecdeque"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get1_unchecked_mut","","",3,{"inputs":[{"name":"vecdeque"},{"name":"usize"}],"output":{"name":"v"}}],[11,"get1_mut","std::collections::hash::map","",4,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"get1_unchecked_mut","","",4,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"v"}}],[11,"get1_mut","collections::btree::map","",5,{"inputs":[{"name":"btreemap"},{"name":"k"}],"output":{"name":"option"}}],[11,"get1_unchecked_mut","","",5,{"inputs":[{"name":"btreemap"},{"name":"k"}],"output":{"name":"v"}}]],"paths":[[4,"SplitMutError"],[8,"SplitMut"],[3,"Vec"],[3,"VecDeque"],[3,"HashMap"],[3,"BTreeMap"]]};
searchIndex['ecmap'] = {"items":[[3,"Iter","ecmap","Iterator struct returned by ECMap::iter_with().",null,null],[3,"IterMut","","Iterator struct returned by ECMap::iter_mut_with().",null,null],[3,"ECMap","","Entity-Component map, implemented as a double HashMap\n(first over component, then over entity).",null,null],[11,"next","","",0,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",1,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"default","","",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"ecmap"}}],[11,"new_custom","","Returns a new ECMap with a custom entity ID type. If you want to use\nECMap::insert_entity (to generate unique entity IDs),\nuse ECMap::new_u32, ECMap::new_usize or ECMap::new_u64 instead.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"ecmap"}}],[11,"insert","","Inserts or replaces an entity component. The old component, if there\nwas one, is returned.\nIf the entity or component did not at all exist, it is also added.",2,{"inputs":[{"name":"ecmap"},{"name":"e"},{"name":"c"}],"output":{"name":"option"}}],[11,"insert_component","","Inserts a component type and enables debugging for that component.\nIn case the component type already exists, nothing is changed and false is returned.  ",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"bool"}}],[11,"get","","Returns a reference to an entity component, or None if it does not exist.",2,{"inputs":[{"name":"ecmap"},{"name":"e"}],"output":{"name":"option"}}],[11,"get_mut","","Returns a mutable reference to an entity component, or None if it does not exist.",2,{"inputs":[{"name":"ecmap"},{"name":"e"}],"output":{"name":"option"}}],[11,"contains","","Check whether an entity component exists.",2,{"inputs":[{"name":"ecmap"},{"name":"e"}],"output":{"name":"bool"}}],[11,"contains_entity","","Check whether an entity exists.",2,{"inputs":[{"name":"ecmap"},{"name":"e"}],"output":{"name":"bool"}}],[11,"contains_component","","Check whether a component exists.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"bool"}}],[11,"remove","","Removes an entity component.",2,{"inputs":[{"name":"ecmap"},{"name":"e"}],"output":{"name":"bool"}}],[11,"remove_entity","","Remove an entity (existing components will no longer have that entity).",2,{"inputs":[{"name":"ecmap"},{"name":"e"}],"output":{"name":"bool"}}],[11,"remove_component","","Remove a component (existing entities will no longer have that component).",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"bool"}}],[11,"clone_with","","Clones the component for all entities and returns a Vec of those.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"vec"}}],[11,"iter_with","","Iterates over all entities having a certain component.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"iter"}}],[11,"iter_mut_with","","Iterates over all entities having a certain component, yielding mutable references.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"itermut"}}],[11,"fmt","","",2,{"inputs":[{"name":"ecmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Returns a new ECMap with u32 as Entity ID.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"ecmap"}}],[11,"new_u32","","Returns a new ECMap with u32 as Entity ID.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"ecmap"}}],[11,"insert_entity","","Generates an Entity ID and inserts it.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"u32"}}],[11,"new_usize","","Returns a new ECMap with usize as Entity ID.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"ecmap"}}],[11,"insert_entity","","Generates an Entity ID and inserts it.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"usize"}}],[11,"new_u64","","Returns a new ECMap with u64 as Entity ID.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"ecmap"}}],[11,"insert_entity","","Generates an Entity ID and inserts it.",2,{"inputs":[{"name":"ecmap"}],"output":{"name":"u64"}}]],"paths":[[3,"Iter"],[3,"IterMut"],[3,"ECMap"]]};
searchIndex['inner'] = {"items":[[8,"IntoResult","inner","Converts a value into a Result.\nYou can implement this for your own types if you want\nto use the `inner!` macro in more ergonomic ways.",null,null],[10,"into_result","","",0,{"inputs":[{"name":"intoresult"}],"output":{"name":"result"}}],[11,"into_result","core::result","",1,{"inputs":[{"name":"result"}],"output":{"name":"result"}}],[11,"into_result","core::option","",2,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[14,"inner!","inner","The `inner!` macro - see module level documentation for details.",null,null],[14,"some!","","Converts your enum to an Option.",null,null],[14,"ok!","","Converts your enum to an Result.",null,null]],"paths":[[8,"IntoResult"],[4,"Result"],[4,"Option"]]};
initSearch(searchIndex);
